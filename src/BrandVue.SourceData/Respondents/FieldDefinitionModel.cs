using System.Collections.Immutable;
using System.Data;
using BrandVue.EntityFramework.Answers;
using BrandVue.EntityFramework.Answers.Model;
using BrandVue.EntityFramework.MetaData.VariableDefinitions;
using BrandVue.EntityFramework.ResponseRepository;
using BrandVue.SourceData.Respondents.TextCoding;
using Microsoft.Extensions.Logging;

namespace BrandVue.SourceData.Respondents
{
    /// <summary>
    /// Per subset information from vue.Questions which allows us to access the data in the response table and describe the shape of data stored in memory.
    /// </summary>
    /// <remarks>
    /// There are many extra mostly unused fields for historical reasons that allowed more complex configuration from the map file
    /// </remarks>
    public class FieldDefinitionModel
    {
        private readonly List<(DbLocation Location, int Value)> _filterDefinitions = new();

        public string Name { get; }
        public string SchemaName { get; }
        public string TableName { get; }

        public DbLocation ValueDbLocation { get; set; }
        /// <summary>
        /// Ordered by response entity type
        /// </summary>
        public ImmutableArray<EntityFieldDefinitionModel> OrderedEntityColumns { get; }
        /// <summary>
        /// Ordered by response entity type
        /// </summary>
        /// <remarks>ALLOC: ImmutableArray can be iterated over without allocating an enumerator. Just be careful of boxing this value type on hot code paths (by passing it to a method that takes an IEnumerable or IReadOnly*)</remarks>
        public ImmutableArray<EntityType> OrderedEntityCombination { get; }
        public IEnumerable<(DbLocation Location, int Value)> FilterColumns => _filterDefinitions;

        public string Question { get; }
        public double? ScaleFactor { get; }

        public SqlRoundingType SqlRoundingType { get; }
        public string FullV2VarCode { get; }
        public EntityInstanceColumnLocation DataValueColumn { get; }
        public string UnsafeSqlVarCodeBase { get; set; }
        public Question QuestionModel { get; set; }
        public string ValueEntityIdentifier { get; }
        public bool ValueIsOpenText { get; }
        public TextLookup Lookup { get; }
        public bool IsAutoGenerated { get; init; } = false;
        public FieldType FieldType { get; set; } = FieldType.Standard;
        internal bool ConfigIncorrect { get; set; }

        public FieldDefinitionModel(string name,
            string schemaName,
            string tableName,
            string valueColumnName,
            string question,
            double? scaleFactor,
            string fullv2VarCode,
            EntityInstanceColumnLocation dataValueColumn,
            string valueEntityIdentifier,
            bool valueIsOpenText,
            TextLookup lookup,
            IEnumerable<EntityFieldDefinitionModel> entityDefinitionModels,
            SqlRoundingType? roundingType)
        {
            Name = name;
            SchemaName = schemaName;
            TableName = tableName;
            ValueDbLocation = new DbLocation(valueColumnName);
            UnsafeSqlVarCodeBase = valueColumnName;
            Question = question;
            ScaleFactor = scaleFactor;
            SqlRoundingType = roundingType ?? SqlRoundingType.Round;
            FullV2VarCode = fullv2VarCode;
            DataValueColumn = dataValueColumn;
            ValueEntityIdentifier = valueEntityIdentifier;
            ValueIsOpenText = valueIsOpenText;
            Lookup = lookup;
            // Ordering must match the one in EntityIds.From
            OrderedEntityColumns = CanonicalColumnOrder(entityDefinitionModels);
            OrderedEntityCombination = OrderedEntityColumns.Select(e => e.EntityType).ToImmutableArray();
        }

        public static ImmutableArray<EntityFieldDefinitionModel> CanonicalColumnOrder(IEnumerable<EntityFieldDefinitionModel> entityDefinitionModels)
        {
            return entityDefinitionModels.OrderBy(m => m.EntityType).ToImmutableArray();
        }

        public void AddFilter((DbLocation Location, int Value) model)
        {
            _filterDefinitions.Add(model);
        }

        public void MapDataColumnsToAnswerColumns(Question q, ILogger logger)
        {
            var dataTableFilters = _filterDefinitions.ToList();
            _filterDefinitions.Clear();
            foreach (var dataTableFilter in dataTableFilters)
            {
                string unquotedSqlColumnName = dataTableFilter.Location.UnquotedColumnName;
                var dataCol =
                    Enum.TryParse<EntityInstanceColumnLocation>(unquotedSqlColumnName, true,
                        out var result)
                        ? result
                        : throw new DataException($"For {q.VarCode} couldn't parse data column name {unquotedSqlColumnName}");
                AddFilter((q.GetDbLocationFromDataColumn(dataCol, logger), dataTableFilter.Value));
            }

            ValueDbLocation = q.GetDbLocationFromDataColumn(DataValueColumn, logger, ValueIsOpenText);
        }

        public string GetSafeSqlColumnFor(EntityType entityType)
        {
            DbLocation tempQualifier = OrderedEntityColumns.Single(d => d.EntityType.Equals(entityType)).DbLocation;
            return tempQualifier.SafeSqlReference;
        }

        public bool OnlyDimensionIsEntityType() => ValueDbLocation is not null && OrderedEntityColumns.OnlyOrDefault()?.DbLocation == ValueDbLocation;
    }

    /// <summary>
    /// These show how a field has been created:
    /// * Standard: Created directly from a question,
    /// * Asked: Autogenerated - if there's an answer choiceset we create a version without that entity for convenience in using as a base
    /// * Base: Autogenerated - if the field is multi-entity we loop the entities and create a single-entity field for each one
    /// </summary>
    public enum FieldType
    {
        Standard,
        Asked,
        Base
    }
}