using System.Numerics;

namespace BrandVue.SourceData.Calculation.Expressions
{
    /// <summary>
    /// In python, bools are just integers. Zero is false, any other integer is true.
    /// </summary>
    internal readonly struct Numeric : IEquatable<Numeric>, IComparable<Numeric>, IComparable, IComparisonOperators<Numeric, Numeric, bool>, IMinMaxValue<Numeric>,
        IAdditionOperators<Numeric, Numeric, Numeric>, ISubtractionOperators<Numeric, Numeric,Numeric>
    {
        private readonly int? _private;

        public Numeric(bool b) : this(b ? 1 : 0){}
        public Numeric(int? intAsInt) => _private = intAsInt;

        public static implicit operator Numeric(int? s) => new Numeric(s);
        public static implicit operator Numeric(int s) => new Numeric(s);
        public static implicit operator Numeric(bool b) => new Numeric(b);

        /// <remarks>Explicit method call rather than implicit cast since maths operations should throw for "None", but don't throw for a nullable int in C#</remarks>
        public int? AsNullable() => _private;

        /// <summary>
        /// Throw if null! Making this a runtime error is a design choice to allow expressions where people are certain there will always be a result.
        /// </summary>
        public static explicit operator int(Numeric n) => n._private.Value;

        /// <summary>
        /// Only use where python coalesces None to False
        /// </summary>
        public bool IsTruthy => _private.HasValue && _private.Value != 0;
        public bool HasValue => _private.HasValue;

        /// <summary>
        /// PERF: Equality methods generated by R# avoid the runtime using reflection for equality check
        /// </summary>
        /// <param name="other"></param>
        /// <returns></returns>
        public bool Equals(Numeric other) => _private == other._private;
        public override bool Equals(object obj) => obj is Numeric other && Equals(other);
        public override int GetHashCode() => _private.GetHashCode();
        public static bool operator ==(Numeric left, Numeric right) => left.Equals(right);
        public static bool operator !=(Numeric left, Numeric right) => !left.Equals(right);

        /// <summary>
        /// R# generated
        /// </summary>
        public int CompareTo(Numeric other)
        {
            return Nullable.Compare(_private, other._private);
        }

        public int CompareTo(object obj)
        {
            return obj is Numeric other ? CompareTo(other) : throw new ArgumentException($"Object must be of type {nameof(Numeric)}");
        }

        public static bool operator >(Numeric left, Numeric right) => left._private.Value > right._private.Value;
        public static bool operator >=(Numeric left, Numeric right) => left._private.Value >= right._private.Value;

        public static bool operator <(Numeric left, Numeric right) => left._private.Value < right._private.Value;
        public static bool operator <=(Numeric left, Numeric right) => left._private.Value <= right._private.Value;
        public static Numeric MaxValue => int.MaxValue;
        public static Numeric MinValue => int.MinValue;
        public static Numeric operator +(Numeric left, Numeric right) => left._private.Value + right._private.Value;
        public static Numeric operator -(Numeric left, Numeric right) => left._private.Value - right._private.Value;
    }
}