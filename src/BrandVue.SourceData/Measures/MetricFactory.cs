using BrandVue.EntityFramework.MetaData;
using BrandVue.SourceData.Calculation.Expressions;
using BrandVue.SourceData.CommonMetadata;
using BrandVue.SourceData.Variable;
using BrandVue.EntityFramework.MetaData.VariableDefinitions;
using BrandVue.SourceData.Calculation.Variables;
using BrandVue.SourceData.Services;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Newtonsoft.Json;
using BrandVue.SourceData.Models;

namespace BrandVue.SourceData.Measures
{
    internal class MetricFactory : IMetricFactory
    {
        private readonly IResponseFieldManager _responseFieldManager;
        private readonly IFieldExpressionParser _fieldExpressionParser;
        private readonly ISubsetRepository _subsetRepository;
        private readonly IReadableVariableConfigurationRepository _variableConfigurationRepository;
        private readonly IVariableFactory _variableFactory;
        private readonly IBaseExpressionGenerator _baseExpressionGenerator;
        private readonly ILogger<MetricFactory> _logger;

        public MetricFactory(IResponseFieldManager responseFieldManager,
            IFieldExpressionParser fieldExpressionParser,
            ISubsetRepository subsetRepository,
            IReadableVariableConfigurationRepository variableConfigurationRepository,
            IVariableFactory variableFactory,
            IBaseExpressionGenerator baseExpressionGenerator, ILogger<MetricFactory> logger = null)
        {
            _responseFieldManager = responseFieldManager;
            _subsetRepository = subsetRepository;
            _variableConfigurationRepository = variableConfigurationRepository;
            _variableFactory = variableFactory;
            _baseExpressionGenerator = baseExpressionGenerator;
            _fieldExpressionParser = fieldExpressionParser;
            _logger = logger ?? NullLogger<MetricFactory>.Instance;
        }

        public bool TryCreateMetric(MetricConfiguration metricConfig, out Measure metric, out string failureMessage)
        {
            metric = null;
            failureMessage = null;
            try
            {
                metric = CreateMetric(metricConfig);
                return true;
            }
            catch (Exception ex)
            {
                failureMessage = ex.Message;
                return false;
            }
        }

        public Measure CreateMetric(MetricConfiguration metricConfig)
        {
            var measure = new Measure();
            LoadMetric(metricConfig, measure);
            return measure;
        }

        public void LoadMetric(MetricConfiguration metricConfig, Measure metric)
        {
            if (metricConfig == null)
            {
                throw GetValidationException("MetricConfiguration", "Object was null");
            }

            ValidateRequiredStringValue(metricConfig.ProductShortCode, nameof(metricConfig.ProductShortCode));
            ValidateRequiredStringValue(metricConfig.CalcType, nameof(metricConfig.CalcType));

            metric.SubsetSpecificBaseDescription = "";
            metric.MarketAverageBaseMeasure = Measure.UseEqualWeightingMeasureId;
            metric.Name = ValidateRequiredStringValue(metricConfig.Name, nameof(metricConfig.Name));
            metric.VarCode = metricConfig.VarCode;
            metric.DisplayName = metricConfig.DisplayName;
            metric.CalculationType = CalculationTypeParser.Parse(metricConfig.CalcType);
            metric.OriginalMetricName = metricConfig.OriginalMetricName;
            metric.GenerationType = metricConfig.IsAutoGenerated;

            LoadFieldInfo(metricConfig, metric);
            LoadBaseFieldInfo(metricConfig, metric);
            if (metric.BaseField is not null)
            {
                metric.BaseDisplayInfo ??= MetricToIncludeValuesConverter.GetFilterInfo(metric.LegacyBaseValues,
                    metric.BaseField.Name, metric.BaseEntityCombination, metric.BaseFieldDependencies,
                    metric.BaseExpression);
            }
            metric.UrlSafeName = null; // Set in initialize method
            metric.ScaleFactor = metricConfig.ScaleFactor;

            if (!string.IsNullOrWhiteSpace(metricConfig.MarketAverageBaseMeasure))
            {
                metric.MarketAverageBaseMeasure = metricConfig.MarketAverageBaseMeasure;
            }
            metric.Description = ValidateOptionalStringValue(metricConfig.Measure);
            metric.HelpText = ValidateOptionalStringValue(metricConfig.HelpText);
            metric.NumberFormat = ValidateOptionalStringValue(metricConfig.NumFormat);
            metric.Minimum = metricConfig.Min;
            metric.Maximum = metricConfig.Max;
            metric.StartDate = metricConfig.StartDate;
            metric.FilterValueMapping = ValidateOptionalStringValue(metricConfig.FilterValueMapping);
            metric.FilterGroup = ValidateOptionalStringValue(metricConfig.FilterGroup);
            metric.FilterMulti = metricConfig.FilterMulti;

            LoadPreNormalisationValueRange(metricConfig, metric);

            metric.DisableMeasure = metricConfig.DisableMeasure;
            metric.DisableFilter = metricConfig.DisableFilter;
            metric.EligibleForMetricComparison = metricConfig.EligibleForMetricComparison;
            metric.Disabled = false;
            metric.HasData = metricConfig.HasData;
            metric.EligibleForCrosstabOrAllVue = metricConfig.EligibleForCrosstabOrAllVue;
            metric.VariableConfigurationId = metricConfig.VariableConfigurationId;
            metric.BaseVariableConfigurationId = metricConfig.BaseVariableConfigurationId;
            metric.DownIsGood = metricConfig.DownIsGood;
            metric.DefaultSplitByEntityTypeName = metricConfig.DefaultSplitByEntityType;
            metric.EntityInstanceIdMeanCalculationValueMapping = metricConfig.EntityInstanceIdMeanCalculationValueMapping == null ? null : JsonConvert.DeserializeObject<EntityMeanMap>(metricConfig.EntityInstanceIdMeanCalculationValueMapping);

            metric.ExcludeList = FieldExtractor.ExtractStringArray(metricConfig.ExcludeList);
            CommonMetadataFieldApplicator.ApplySubsets(metric, _subsetRepository, metricConfig.Subset);
            metric.Environment = Array.Empty<string>();

            metric.Initialize();
        }

        private void LoadPreNormalisationValueRange(MetricConfiguration metricConfig, Measure measure)
        {
            measure.PreNormalisationMinimum = MetricValueParser.ParseNullableInteger(metricConfig.PreNormalisationMinimum);
            measure.PreNormalisationMaximum = MetricValueParser.ParseNullableInteger(metricConfig.PreNormalisationMaximum);

            if (measure.PreNormalisationMinimum == null && measure.PreNormalisationMaximum == null)
            {
                return;
            }

            if (measure.PreNormalisationMinimum == null || measure.PreNormalisationMaximum == null)
            {
                throw GetValidationException(
                    $@"Error in pre-normalisation value range for measure '{
                        measure.Name
                    }'. You must either leave both preNormalisationMinimum and preNormalisationMaximum unset, or you must set both of them. However, in this case preNormalisationMinimum = {
                        measure.PreNormalisationMinimum?.ToString() ?? "null"
                    } and preNormalisationMaximum = {
                        measure.PreNormalisationMaximum?.ToString() ?? "null"
                    }.");
            }

            if (measure.PreNormalisationMinimum
                >= measure.PreNormalisationMaximum)
            {
                throw GetValidationException(
                    $@"Error in pre-normalisation value range for measure '{
                        measure.Name
                    }': minimum ({
                        measure.PreNormalisationMinimum
                    }) must be less than maximum ({
                        measure.PreNormalisationMaximum
                    }) but is not, and this makes me sad.");
            }
        }

        private void WrapMeasureTrueVals(Measure measure, IVariable<int?> variable, string identifier)
        {
            var originalPrimaryValues = measure.LegacyPrimaryTrueValues;
            measure.PrimaryDisplayInfo = MetricToIncludeValuesConverter.GetFilterInfo(
                measure.LegacyPrimaryTrueValues, identifier, measure.EntityCombination,
                measure.PrimaryFieldDependencies, measure.PrimaryVariable);
            var hasCustomFieldExpression = measure.HasCustomFieldExpression;
            measure.PrimaryVariable = measure.CalculationType == CalculationType.Text
                ? variable
                : new FilteredVariable(variable, originalPrimaryValues.Contains);
            measure.HasCustomFieldExpression = hasCustomFieldExpression;
            measure.Field = null;
            measure.LegacyPrimaryTrueValues = null;
            measure.FieldOperation = FieldOperation.None;
        }

        private string[] SetRawTrueVals(MetricConfiguration metricConfig, Measure measure)
        {
            return SetPrimaryValues(metricConfig, measure.LegacyPrimaryTrueValues);
        }

        public static string[] SetPrimaryValues(MetricConfiguration metricConfig, AllowedValues allowedValues)
        {
            string[] rawTrueVals = metricConfig.TrueVals?.Split('¦');
            (bool success, string errorMessage) = MetricValueParser.TryParseMultipleValueSpecification(
                MetricFields.TrueValues,
                rawTrueVals?.FirstOrDefault(),
                (min, max) => MetricValueSetter.SetLegacyPrimaryTrueValueRange(allowedValues, min, max),
                range => MetricValueSetter.SetPrimaryDiscreteTrueValues(allowedValues, range));
            if (!success)
            {
                throw GetValidationException(errorMessage);
            }

            return rawTrueVals;
        }

        public static void SetBaseValues(MetricConfiguration metricConfig, AllowedValues allowedValues)
        {
            var (success, errorMessage) = MetricValueParser.TryParseMultipleValueSpecification(
                MetricFields.BaseValues,
                metricConfig.BaseVals,
                (min, max) => MetricValueSetter.SetBaseValueRange(allowedValues, min, max),
                range => MetricValueSetter.SetDiscreteBaseValues(allowedValues, range));

            if (!success)
            {
                throw GetValidationException(errorMessage);
            }
        }

        private void LoadFieldInfo(MetricConfiguration metricConfig, Measure measure)
        {
            // Reset these since existing measures are passed in and we want to early return in some cases
            measure.PrimaryVariable = null;
            measure.PrimaryVariableIdentifier = null;
            measure.HasCustomFieldExpression = false;
            measure.QuestionShownInSurvey = false;
            measure.Field = null;
            measure.Field2 = null;
            measure.FieldOperation = FieldOperation.None;
            measure.LegacyPrimaryTrueValues = null;
            measure.LegacySecondaryTrueValues = null;
            measure.NumericVariableField = null;

            if (metricConfig.VariableConfigurationId.HasValue)
            {
                var variableId = metricConfig.VariableConfigurationId.Value;
                var variableConfig = _variableConfigurationRepository.Get(variableId);
                if (variableConfig != null)
                {
                    measure.PrimaryVariable = _variableFactory.GetDeclaredVariable(variableConfig);
                    measure.PrimaryVariableIdentifier = variableConfig.Identifier;
                    measure.HasCustomFieldExpression = variableConfig.Definition is FieldExpressionVariableDefinition;
                    measure.QuestionShownInSurvey = true;

                    if (TryGetNumericField(variableConfig.Definition, out var numericField))
                    {
                        measure.NumericVariableField = numericField;
                    }

                    if (!string.IsNullOrWhiteSpace(metricConfig.TrueVals))
                    {
                        SetRawTrueVals(metricConfig, measure);
                        WrapMeasureTrueVals(measure, measure.PrimaryVariable, variableConfig.Identifier);
                    }

                    return;
                }
                _logger.LogError("{productShortCode}{subProductId} metric {id} {name} has non-existing variable {varId}", metricConfig.ProductShortCode, metricConfig.SubProductId, metricConfig.Id, metricConfig.DisplayName, metricConfig.VariableConfigurationId);
            }

            if (!string.IsNullOrWhiteSpace(metricConfig.FieldExpression))
            {
                // If variable expression is used, it overrides any other field related settings.
                measure.PrimaryVariable = _fieldExpressionParser.ParseUserNumericExpressionOrNull(metricConfig.FieldExpression);
                measure.QuestionShownInSurvey = true;
                measure.PrimaryVariableIdentifier = metricConfig.Field;

                if (!string.IsNullOrWhiteSpace(metricConfig.TrueVals))
                {
                    var splitTrueVals = metricConfig.TrueVals?.Split('¦');
                    PossiblySetSecondaryValues(measure, splitTrueVals);
                    SetRawTrueVals(metricConfig, measure);
                    WrapMeasureTrueVals(measure, measure.PrimaryVariable, metricConfig.Field);
                }

                return;
            }

            measure.Field = _responseFieldManager.Get(metricConfig.Field);
            measure.FieldOperation = FieldOperationParser.Parse(metricConfig.FieldOp);
            measure.QuestionShownInSurvey = measure.Field?.WasQuestionShownInSurvey() ?? false;

            if (measure.CalculationType == CalculationType.Text)
            {
                if (!string.IsNullOrWhiteSpace(metricConfig.TrueVals))
                {
                    throw GetValidationException(nameof(metricConfig.TrueVals), "Value must be null for text calculation type");
                }
            }

            string[] rawTrueVals = SetRawTrueVals(metricConfig, measure);
            if (measure.Field is { } field)
            {
                measure.PrimaryVariableIdentifier = field.Name;

                if (!string.IsNullOrWhiteSpace(metricConfig.Field2))
                {
                    measure.Field2 = _responseFieldManager.Get(metricConfig.Field2);
                    measure.PrimaryVariableIdentifier = null;
                }
                else if (_fieldExpressionParser.GetDeclaredVariableOrNull(field) is { } variable)
                {
                    if (!metricConfig.DisableFilter && !string.IsNullOrWhiteSpace(metricConfig.FilterValueMapping))
                    {
                        // Because a metric being used as a filter ignores the true vals, we can't filter.
                        // So this relies on the existing bug that the Field and TrueVals will still get used if both are set...
                        // If we used the FilterValueMappingVariable (which could just become FilterVariable) consistently everywhere, or separated out the concept of filters, this horrible hack could go away
                        measure.PrimaryVariable = variable;
                    }
                    else
                    {
                        WrapMeasureTrueVals(measure, variable, field.Name);
                    }

                    measure.HasCustomFieldExpression = false;
                }
            }

            // Fall back on primary if not set independently (stops everything breaking during transition, long term shouldn't be needed, though longer term we'd prefer a DSL)
            (bool success, string errorMessage) = PossiblySetSecondaryValues(measure, rawTrueVals);
            if (!success)
            {
                throw GetValidationException(errorMessage);
            }
        }

        private (bool success, string errorMessage) PossiblySetSecondaryValues(Measure measure, string[] rawTrueVals)
        {
            string secondaryRawTrueVals = rawTrueVals?.LastOrDefault();
            return MetricValueParser.TryParseMultipleValueSpecification(
                MetricFields.TrueValues,
                secondaryRawTrueVals,
                (min, max) => MetricValueSetter.SetSecondaryTrueValueRange(measure, min, max),
                range => MetricValueSetter.SetSecondaryDiscreteTrueValues(measure, range));
        }

        private void LoadBaseFieldInfo(MetricConfiguration metricConfig, Measure measure)
        {
            // Reset these since existing measures are passed in and we want to early return in some cases
            measure.BaseExpression = null;
            measure.BaseExpressionString = null;
            measure.BaseField = null;
            measure.LegacyBaseValues = null;
            measure.LegacyBaseValues = null;
            measure.BaseDisplayInfo = null;
            measure.HasCustomBase = false;

            if (metricConfig.BaseVariableConfigurationId.HasValue)
            {
                var expression = _fieldExpressionParser.GetDeclaredBooleanVariableOrNull(metricConfig.BaseVariableConfiguration.Identifier)
                    ?? throw new InvalidOperationException($"Could not find variable `{metricConfig.BaseVariableConfiguration.Identifier}`");
                measure.BaseExpression = expression;
                measure.BaseExpressionString = expression is BooleanVariable {DisplayExpressionString: {} str} ? str : "";
                return;
            }

            if (!string.IsNullOrWhiteSpace(metricConfig.BaseExpression))
            {
                // If base expression is used, it overrides any other base field related settings.
                measure.BaseExpression = _fieldExpressionParser.ParseUserBooleanExpression(metricConfig.BaseExpression);
                measure.BaseExpressionString = metricConfig.BaseExpression;
                return;
            }

            SetBaseValues(metricConfig, measure.LegacyBaseValues);

            metricConfig.BaseField = string.IsNullOrWhiteSpace(metricConfig.BaseField) && !string.IsNullOrWhiteSpace(metricConfig.Field) && !string.IsNullOrWhiteSpace(metricConfig.BaseVals)
                ? metricConfig.Field
                : metricConfig.BaseField;

            if (!string.IsNullOrWhiteSpace(metricConfig.BaseField))
            {
                measure.BaseField = _responseFieldManager.Get(metricConfig.BaseField);
                try
                {
                    if (_fieldExpressionParser.GetDeclaredVariableOrNull(measure.BaseField) is { } baseVariable)
                    {
                        measure.BaseDisplayInfo = MetricToIncludeValuesConverter.GetFilterInfo(measure.LegacyBaseValues,
                            measure.BaseField?.Name, measure.BaseEntityCombination, measure.BaseFieldDependencies,
                            measure.BaseExpression);
                        var originalBaseValues = measure.LegacyBaseValues;
                        Func<int?, bool> predicate = measure.BaseField.IsTextFieldForAllSubsets()
                            ? v => v.HasValue
                            : originalBaseValues.Contains;
                        measure.BaseExpression = new BooleanFromValueVariable(baseVariable, predicate);
                        measure.BaseField = null;
                        measure.LegacyBaseValues = new();
                    }
                }
                catch (Exception e)
                {
                    _logger.LogError($"Measure {measure.Name} could not be converted to a base expression, falling back to using base field", e);
                }
            }
        }

        private static string ValidateOptionalStringValue(string value)
        {
            if (string.IsNullOrWhiteSpace(value))
            {
                return null;
            }

            return value;
        }

        private static string ValidateRequiredStringValue(string value, string fieldName)
        {
            if (string.IsNullOrWhiteSpace(value))
            {
                throw GetValidationException(fieldName, "Field is required");
            }

            return value;
        }

        private static Exception GetValidationException(string fieldName, string failureMessage)
        {
            return GetValidationException($"Validation of field: {fieldName} failed with message: {failureMessage}");
        }

        private static Exception GetValidationException(string message)
        {
            // To remain backwards compatible with the map file loading logic, we use the same exception here.
            return new InvalidOperationException(message);
        }

        private bool TryGetNumericField(VariableDefinition variableDefinition, out ResponseFieldDescriptor field)
        {
            if (variableDefinition != null && variableDefinition is GroupedVariableDefinition groupedVariableDefinition)
            {
                var variableComponents = groupedVariableDefinition.Groups.SelectMany(g => GetNestedComponents(g.Component));
                if (variableComponents.All(c => c is InclusiveRangeVariableComponent))
                {
                    var distinctSourceIdentifiers = variableComponents.Select(c => ((InclusiveRangeVariableComponent)c).FromVariableIdentifier).Distinct().ToArray();
                    if (distinctSourceIdentifiers.Length == 1)
                    {
                        var identifier = distinctSourceIdentifiers.Single();
                        if (_responseFieldManager.TryGet(identifier, out var loadedField) && loadedField.IsNumericField())
                        {
                            field = loadedField;
                            return true;
                        }
                    }
                }
            }
            field = null;
            return false;
        }

        private IEnumerable<VariableComponent> GetNestedComponents(VariableComponent component)
        {
            if (component is CompositeVariableComponent compositeComponent)
            {
                return compositeComponent.CompositeVariableComponents.SelectMany(c => GetNestedComponents(c));
            }
            return component.Yield();
        }
    }
}
