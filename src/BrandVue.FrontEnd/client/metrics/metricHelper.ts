import { Metric } from './metric';
import {AutoGenerationType, CalculationType} from "../BrandVueApi";
import { Significance, MainQuestionType } from "../BrandVueApi";
import { VariableListItem } from 'client/components/visualisations/Crosstab/VariableListItem';

export const getMetricOrThrow = (metrics: Metric[], metricName): Metric => {
    const foundMetrics = metrics.filter(m => m.name === metricName);
    if (foundMetrics.length !== 1) {
        throw new Error(`Found ${foundMetrics.length} with the name ${metricName}, only 1 metric was expected.`);
    }

    return foundMetrics[0];
}

const eoMarketMetricsCalcTypes = [ CalculationType.EoTotalSpendPerTimeOfDay, CalculationType.EoTotalSpendPerLocation ]
export const isEatingOutMarketMetric = (metric: Metric): boolean => eoMarketMetricsCalcTypes.includes(metric.calcType);

export enum SignificanceMeaning {
    Neutral = <any>"Neutral",
    Good = <any>"Good",
    Bad = <any>"Bad"
}

export const getSignificanceMeaning = (significance: Significance, downIsGood: boolean) : SignificanceMeaning => {
    if (significance === Significance.None)
        return SignificanceMeaning.Neutral;

    if (downIsGood) {
        return significance === Significance.Down ? SignificanceMeaning.Good : SignificanceMeaning.Bad;
    }

    return significance === Significance.Down ? SignificanceMeaning.Bad : SignificanceMeaning.Good;
}

export const separateMetricsByGenerationType = (metrics: Metric[]) => {
    const customMetrics = metrics.filter(m => m.generationType == AutoGenerationType.Original && m.variableConfigurationId != undefined);
    const standardMetrics = metrics.filter(m => m.generationType == AutoGenerationType.CreatedFromField  || m.variableConfigurationId == undefined);
    const autoGeneratedNumericMetrics = metrics.filter(m => m.generationType == AutoGenerationType.CreatedFromNumeric);

    return [customMetrics, standardMetrics, autoGeneratedNumericMetrics]
}

export const isSingleChoiceOrVariable = (metric: Metric, questionTypeLookup: { [key: string]: MainQuestionType; }) : boolean => {
    return questionTypeLookup[metric.name] == MainQuestionType.SingleChoice || questionTypeLookup[metric.name] == MainQuestionType.CustomVariable;
}

const doesMetricMatchSearch = (metric: Metric, normalizedSearchText: string): boolean => {
    return (
        metric.name.toLocaleUpperCase().includes(normalizedSearchText) ||
        metric.varCode?.toLocaleUpperCase().includes(normalizedSearchText) ||
        metric.helpText?.toLocaleUpperCase().includes(normalizedSearchText) ||
        metric.displayName?.toLocaleUpperCase().includes(normalizedSearchText) ||
        metric.primaryVariableIdentifier?.toLocaleUpperCase().includes(normalizedSearchText)
    );
};
  
export const metricsThatMatchSearchText = (searchText: string, metrics: Metric[]): Metric[] => {
    const normalizedSearchText = searchText.trim().toLocaleUpperCase();
    return metrics.filter(metric => doesMetricMatchSearch(metric, normalizedSearchText));
};
  
export const metricsThatMatchSearchTextByVariableListItems = (searchText: string, variableListItems: VariableListItem[]): VariableListItem[] => {
    if (!searchText || searchText.trim() === '') {
        return variableListItems;
    }
    const normalizedSearchText = searchText.trim().toLocaleUpperCase();
    return variableListItems.filter(item => doesMetricMatchSearch(item.metric, normalizedSearchText));
};

export const metricSupportsWeighting = (metric: Metric|undefined, questionTypeLookup: { [key: string]: MainQuestionType; }): boolean  => {
    const metricQuestionType = metric ? questionTypeLookup[metric.name] : MainQuestionType.Unknown;
    return metricQuestionType !== MainQuestionType.HeatmapImage && metricQuestionType !== MainQuestionType.Text;
}
