import React, {useContext, useEffect, useMemo, useState} from 'react';
import {Metric} from "../../../metrics/metric";
import SearchInput from '../../SearchInput';
import {getSplitByAndFilterByEntityTypesForMetric} from '../../helpers/SurveyVueUtils';
import { IGoogleTagManager } from '../../../googleTagManager';
import {
    AutoGenerationType,
    IEntityType,
    QuestionVariableDefinition,
    VariableConfigurationModel,
    PermissionFeaturesOptions,
} from '../../../BrandVueApi';
import {PageHandler} from '../../PageHandler';
import {ProductConfigurationContext} from '../../../ProductConfigurationContext';
import {isCrosstabAdministrator} from '../../helpers/FeaturesHelper';
import {useEntityConfigurationStateContext} from '../../../entity/EntityConfigurationStateContext';
import MetricListItem from './MetricListItem';
import {metricsThatMatchSearchTextByVariableListItems} from '../../../metrics/metricHelper';
import {VariableType} from './VariableType';
import {VariableListItem} from './VariableListItem';
import { useAppSelector } from 'client/state/store';
import { selectHydratedVariableConfiguration } from 'client/state/variableConfigurationSelectors';

const selectedQuestionId = "selectedQuestion";

interface ISearchableQuestionListProps {
    googleTagManager: IGoogleTagManager;
    pageHandler: PageHandler;
    metrics: Metric[];
    selectedMetric: Metric | undefined;
    selectedMetricSplitByType: IEntityType | undefined;
    setEligibleForCrosstabOrAllVue(metric: Metric, isEligible: boolean): Promise<void>;
    setMetricEnabled(metric: Metric, isMetricEnabled: boolean): Promise<void>;
    setFilterForMetricEnabled(metric: Metric, isMetricEnabled: boolean): Promise<void>;
    setMetricDefaultSplitBy(metric: Metric, entityType: IEntityType): Promise<void>;
    selectMetric(metric: Metric): void;
    setConvertCalculationTypeModalVisible(): void;
    buttonGroup: React.ReactNode;
    groupCustomVariables: boolean;
    showHamburger: boolean;
    subsetId: string;
}

const SearchableQuestionList = (props: ISearchableQuestionListProps) => {
    const [searchText, setSearchText] = useState<string>('');
    const { productConfiguration } = useContext(ProductConfigurationContext);
    const { entityConfiguration } = useEntityConfigurationStateContext();
    const { variables } = useAppSelector(selectHydratedVariableConfiguration);
    
    useEffect(() => {
        window.requestAnimationFrame(() => {
            const selectedElement = document.getElementById(selectedQuestionId);
            if (selectedElement) {
                setTimeout(() => selectedElement.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "start" }), 150);
            }
        });
    }, [props.selectedMetric]);
    
    const { allMatched, customMetrics, autoGeneratedNumericMetrics, standardMetrics, otherMetrics } = useMemo(
        () => getGroupedVariableListItems(variables, props.metrics, searchText),
        [variables, props.metrics, searchText]
    );

    const getMetricElement = (variableListItem: VariableListItem, canEditMetrics: boolean) => {
        const metric = variableListItem.metric;
        const entityTypes = getSplitByAndFilterByEntityTypesForMetric(metric, entityConfiguration);
        let splitByEntityType = entityTypes.splitByEntityType;
        if (metric.name == props.selectedMetric?.name && props.selectedMetricSplitByType) {
            splitByEntityType = props.selectedMetricSplitByType;
        }
        return (
            <MetricListItem
                googleTagManager={props.googleTagManager}
                pageHandler={props.pageHandler}
                variableListItem={variableListItem}
                splitByEntityType={splitByEntityType}
                isSelected={props.selectedMetric?.name === metric.name}
                canEditMetrics={canEditMetrics}
                setEligibleForCrosstabOrAllVue={(isEligible: boolean) => props.setEligibleForCrosstabOrAllVue(metric, isEligible)}
                setMetricEnabled={(isMetricEnabled: boolean) => props.setMetricEnabled(metric, isMetricEnabled)}
                setFilterForMetricEnabled={(isFilterForMetricEnabled: boolean) => props.setFilterForMetricEnabled(metric, isFilterForMetricEnabled)}
                setMetricDefaultSplitBy={(type) => props.setMetricDefaultSplitBy(metric, type)}
                showHamburger={props.showHamburger}
                selectMetric={() => props.selectMetric(metric)}
                key={metric.name}
                groupCustomVariables={props.groupCustomVariables}
                setConvertCalculationTypeModalVisible={props.setConvertCalculationTypeModalVisible}
                subsetId={props.subsetId}
            />
        );
    };

    const renderMetricList = (isCrosstabAdminEdit:boolean) => {

        if (!props.groupCustomVariables) {
            return allMatched.map(v => getMetricElement(v, isCrosstabAdminEdit));
        }
        return (
            <>
                {customMetrics.length > 0 && <div className="metric-list-item title">Custom variables</div>}
                {customMetrics.map(v => getMetricElement(v, isCrosstabAdminEdit))}
                {autoGeneratedNumericMetrics.length > 0 && <div className="metric-list-item title">Automatically generated</div>}
                {autoGeneratedNumericMetrics.map(v => getMetricElement(v, isCrosstabAdminEdit))}
                {standardMetrics.length > 0 && <div className="metric-list-item title">Questions</div>}
                {standardMetrics.map(v => getMetricElement(v, isCrosstabAdminEdit))}
                {otherMetrics.length > 0 && <div className="metric-list-item title">Others</div>}
                {otherMetrics.map(v => getMetricElement(v, isCrosstabAdminEdit))}
            </>
        );
    };

    const isCrosstabAdminEdit = isCrosstabAdministrator(productConfiguration);

    return (
        <div className="question-list-container">
            <div className="question-search-container">
                <SearchInput 
                    id="question-search" 
                    onChange={setSearchText} 
                    text={searchText} 
                    className="question-search-input-group" 
                    autoFocus={true} 
                />
            </div>
            {props.buttonGroup}
            <div className="question-list">
                {renderMetricList(isCrosstabAdminEdit)}
            </div>
        </div>
    );
};

export default SearchableQuestionList;

function getGroupedVariableListItems(variables: VariableConfigurationModel[], metrics: Metric[], searchText: string) {
    const variableListItems = getVariableListItems(variables, metrics);
    const allMatched = metricsThatMatchSearchTextByVariableListItems(searchText, variableListItems);
    const customMetrics = allMatched.filter(v => v.variableType === VariableType.Custom && v.metric.variableConfigurationId != undefined);
    const autoGeneratedNumericMetrics = allMatched.filter(v => v.variableType === VariableType.AutoGeneratedNumeric);
    const standardMetrics = allMatched.filter(v => v.variableType === VariableType.Question);
    const otherMetrics = allMatched.filter(v => v.variableType === VariableType.Custom && v.metric.variableConfigurationId === undefined);
    return { allMatched, customMetrics, autoGeneratedNumericMetrics, standardMetrics, otherMetrics };
}

function getVariableListItems(variables: VariableConfigurationModel[], metrics: Metric[]) {
    const variableByIdentifier = new Map<string, VariableConfigurationModel>(variables.map(v => [v.identifier, v]));
    return metrics.map(metric => {
        const variable = variableByIdentifier.get(metric.primaryVariableIdentifier);
        let variableType = VariableType.Custom;

        if (variable?.definition instanceof QuestionVariableDefinition) {
            variableType = VariableType.Question;
        } else if (metric.generationType === AutoGenerationType.CreatedFromNumeric) {
            variableType = VariableType.AutoGeneratedNumeric;
        }

        return {metric, variable, variableType};
    });
};
