
/// <reference types="jest" />
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import * as BrandVueApi from "../../../../BrandVueApi";
import { jest, describe, test, beforeAll, beforeEach, expect } from '@jest/globals';

import AddToReportModal from './AddToReportModal';
import * as SavedReportsContext from '../SavedReportsContext';
import * as PagesHelper from '../../../helpers/PagesHelper';
import * as ReportPageBuilder from '../Utility/ReportPageBuilder';
import * as CrosstabContext from '../../Crosstab/CrosstabPageStateContext';
import * as EntityConfigContext from '../../../../entity/EntityConfigurationStateContext';
import * as MetricStateContext from '../../../../metrics/MetricStateContext';
import * as Store from '../../../../state/store';
import { AutoGenerationType } from '../../../../BrandVueApi';
import { PartType } from '../../../../components/panes/PartType';
import { Metric } from 'client/metrics/metric';

describe('AddToReportModal - definePartFromMetricAndCrosstabState', () => {
    const mockReportsDispatch = jest.fn(() => Promise.resolve());
    const mockReport = { savedReportId: 'r1', pageId: 'page1', reportType: 'table', waves: undefined } as any;
    const preSelectedMetric = new Metric({
        id: 1,
        productShortCode: "shortCode",
        subProductId: "subproduct",
        name: "metric1",
        displayName: "metric1",
        variableConfigurationId: undefined,
        calcType: "sum",
        subset: "all",
        primaryVariableIdentifier: undefined,
        fieldExpression: "field1",
        field: "field1",
        field2: "field2",
        fieldOp: "fieldOp",
        trueVals: "trueVals",
        baseVariableConfigurationId: undefined,
        baseExpression: "baseExpression",
        baseField: "baseField",
        baseVals: "baseVals",
        helpText: "helpText",
        numFormat: "string",
        disableMeasure: false,
        min: undefined,
        max: undefined,
        eligibleForMetricComparison: false,
        eligibleForCrosstabOrAllVue: false,
        downIsGood: false,
        defaultSplitByEntityType: "",
        isAutoGenerated: AutoGenerationType.Original,
        disableFilter: false,
        filterMulti: false,
        filterValueMapping: "",
        hasData: false,
        originalMetricName: undefined,
        excludeWaves: undefined,
        entityInstanceIdMeanCalculationValueMapping: undefined,
        scaleFactor: undefined,
        measure: "",
        varCode: "",
        filterGroup: "",
        preNormalisationMinimum: undefined,
        preNormalisationMaximum: undefined,
        excludeList: "",
        marketAverageBaseMeasure: "",
        keyImage: ""
    })

    // Base part that getPartFromMetric will return (we assert that the component mutates this)
    const part: BrandVueApi.PartDescriptor = new BrandVueApi.PartDescriptor();

    // Mutable crosstab state so tests can change it before render
    let mockCrosstabState: any = { categories: ['A'], selectedAverages: ['avg1'], resultSortingOrder: 'desc' };

    beforeAll(() => {
        // ensure ReportType.Table used in filtering matches our mock report
        (BrandVueApi as any).ReportType = { Table: 'table' };

        jest.spyOn(SavedReportsContext, 'useSavedReportsContext').mockReturnValue({
            reportsDispatch: mockReportsDispatch,
            reports: [mockReport],
        } as any);

        jest.spyOn(PagesHelper, 'getReportsPage').mockReturnValue({
            childPages: [
                {
                    id: 'page1',
                    panes: [ { id: 'pane1', parts: [1, 2] } ]
                }
            ]
        } as any);

        jest.spyOn(ReportPageBuilder, 'getPartFromMetric').mockImplementation(() => {
            // Ensure the mocked part has the expected partType so the component dispatch picks it up
            part.partType = PartType.ReportsTable as any;
            return part;
        });

        jest.spyOn(CrosstabContext, 'useCrosstabPageStateContext').mockImplementation(() => ({ crosstabPageState: mockCrosstabState } as any));

        jest.spyOn(EntityConfigContext, 'useEntityConfigurationStateContext').mockReturnValue({ entityConfiguration: {} } as any);
        jest.spyOn(MetricStateContext, 'useMetricStateContext').mockReturnValue({ questionTypeLookup: {} } as any);

        const fakeState: any = {
            subset: { subsetId: 'subset1' },
            report: { allReports: [mockReport] }
        };

        // Make the selector operate against a fake RootState so selectors like selectSubsetId and selectAllReports work
        jest.spyOn(Store, 'useAppSelector').mockImplementation((selector: any) => {
            if (typeof selector === 'function') {
                return selector(fakeState);
            }
            return undefined as any;
        });
    });

    test('adds part with values from crosstabPageState (case 1)', async () => {
        mockCrosstabState = { categories: ['A', 'B'], selectedAverages: ['avg1'], resultSortingOrder: 'desc' };

        // Update the implementation of the crosstab hook to return current mutable state
        (CrosstabContext.useCrosstabPageStateContext as jest.Mock).mockImplementation(() => (
            { crosstabPageState: mockCrosstabState })
        );

        render(<AddToReportModal isOpen={true} setIsOpen={() => {}} preSelectedMetric={preSelectedMetric} />);

        const addButton = screen.getByTestId('primary-button');
        fireEvent.click(addButton);

        await waitFor(() => expect(mockReportsDispatch).toHaveBeenCalled());

        const action = (mockReportsDispatch as any).mock.calls[0][0];
        expect(action.type).toBe('ADD_PARTS');
        const dispatchedPart = action.data.parts[0];

        expect(dispatchedPart.breaks).toEqual(mockCrosstabState.categories);
        expect(dispatchedPart.overrideReportBreaks).toBe(true);
        expect(dispatchedPart.averageTypes).toEqual(mockCrosstabState.selectedAverages);
        expect(dispatchedPart.reportOrder).toEqual(mockCrosstabState.resultSortingOrder);
        expect(dispatchedPart.partType).toEqual(PartType.ReportsTable);
        expect(dispatchedPart.spec1).toBe(preSelectedMetric.name);
        expect(dispatchedPart.helpText).toBe(preSelectedMetric.helpText);
    });
});
