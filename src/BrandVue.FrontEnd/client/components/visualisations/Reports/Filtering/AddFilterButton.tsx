import React from 'react';
import { Metric } from '../../../../metrics/metric';
import { IApplicationUser, PermissionFeaturesOptions, ReportVariableAppendType } from '../../../../BrandVueApi';
import { getMetricDisplayName } from '../../../../components/helpers/SurveyVueUtils';
import { useFilterStateContext } from '../../../../filter/FilterStateContext';
import FilterValueMappingSelector from './FilterValueMappingSelector';
import { MetricFilterState } from '../../../../filter/metricFilterState';
import { ButtonDropdown, DropdownToggle, DropdownMenu, DropdownItem } from 'reactstrap';
import SearchInput from '../../../../components/SearchInput';
import { CSSTransition } from "react-transition-group";
import VariableContentModal from "../../Variables/VariableModal/VariableContentModal";
import { MixPanel } from '../../../mixpanel/MixPanel';
import { metricsThatMatchSearchText, separateMetricsByGenerationType } from '../../../../metrics/metricHelper';
import { useAppSelector } from 'client/state/store';
import { selectSubsetId } from 'client/state/subsetSlice';
import FeatureGuard from 'client/components/FeatureGuard/FeatureGuard';
import { ProductConfigurationContext } from "client/ProductConfigurationContext";

interface IAddFilterButton {
    end?: boolean;
    separateVariables?: boolean;
    buttonType: FilterButtonType;
    openModalToFilterPage?: () => void;
}

export enum FilterButtonType {
    ShowVariableModal,
    ShowReportFilterModal
}

const AddFilterButton = (props: IAddFilterButton) => {
    const {productConfiguration} = React.useContext(ProductConfigurationContext);
    const [isOpen, setIsOpen] = React.useState(false);
    const [selectedMetric, setSelectedMetric] = React.useState<Metric | undefined>(undefined);
    const [secondPageActive, setSecondPageActive] = React.useState(false);
    const [selectedFilters, setSelectedFilters] = React.useState<MetricFilterState[]>([]);
    const [searchQuery, setSearchQuery] = React.useState<string>("");
    const [isVariableModalOpen, setIsVariableModalOpen] = React.useState<boolean>(false);
    const { metricsValidAsFilter, filterDispatch } = useFilterStateContext();
    const subsetId = useAppSelector(selectSubsetId);

    const goToSecondPage = (metric: Metric) => {
        setSelectedMetric(metric);
        setSecondPageActive(true);
    }

    const goToFirstPage = () => {
        setSecondPageActive(false);
        setSelectedFilters([]);
    }

    const toggle = () => {
        isOpen ? MixPanel.track("filtersClosed") : MixPanel.track("filtersOpened");
        setIsOpen(!isOpen);
        setSearchQuery('');

        setSelectedMetric(undefined);
        goToFirstPage();
    }

    const getMatchedMetrics = () => {
        let matchedMetrics = metricsValidAsFilter;

        if (searchQuery && searchQuery.trim() != '') {
            matchedMetrics = metricsThatMatchSearchText(searchQuery, matchedMetrics);
        }

        if (props.separateVariables) {
            const [customMetrics, standardMetrics, autoGeneratedNumericMetrics] = separateMetricsByGenerationType(matchedMetrics);
            const standardAndAutoGenerated = standardMetrics.concat(autoGeneratedNumericMetrics);
            return (
                <div className="dropdown-metrics">
                    {customMetrics.length > 0 && <div className="dropdown-item title">Custom variables</div>}
                    {customMetrics.map(metric => getMetricElement(metric))}
                    {standardAndAutoGenerated.length > 0 && <div className="dropdown-item title">Questions</div>}
                    {standardAndAutoGenerated.map(metric => getMetricElement(metric))}
                </div>
            );
        }

        if (metricsValidAsFilter.length == 0) {
            return (
                <div className="no-filters-message">
                    <p>All report filters have been applied.</p>
                    <p>To apply more filters, you first need to create them.</p>
                </div>
            );
        }

        return (
            <div className="dropdown-metrics">
                {matchedMetrics.map(metric => getMetricElement(metric))}
            </div>
        );
    }

    const getNewVariableButton = () => {
        if (props.buttonType === FilterButtonType.ShowVariableModal) {
            return (
                <FeatureGuard permissions={[PermissionFeaturesOptions.VariablesCreate]} 
                    customCheck={(userContext, isAuthorized) => !!(
                        (userContext.isSystemAdministrator || 
                            (productConfiguration.isSurveyVue() && isAuthorized))
                        )
                    }
                    >
                    <button id="new-variable-button" className={`hollow-button new-variable-button`} onClick={() => setIsVariableModalOpen(true)}>
                        <i className="material-symbols-outlined">add</i>
                        <div className="new-variable-button-text">Create new variable</div>
                    </button>
                </FeatureGuard>
            );
        }

        return null;
    }

    const getMetricElement = (metric: Metric) => {
        const displayText = getMetricDisplayName(metric);
        return (
            <button key={metric.name} onClick={() => goToSecondPage(metric)} title={metric.varCode} className="dropdown-item tabbed">
                <div className="name-container">
                    {!metric.isBasedOnCustomVariable && <span className='var-name'>{metric.varCode}</span>}
                    <span className='title' title={displayText}>{displayText}</span>
                </div>
                <i className="material-symbols-outlined forward-icon">chevron_right</i>
            </button>
        );
    }

    const applyFilter = (filters: MetricFilterState[] | undefined) => {
        if (selectedMetric && filters) {
            filterDispatch({
                type: "UPDATE_FILTER",
                data: {
                    metricName: selectedMetric.name,
                    filters: filters
                },
            });
        } else {
            throw new Error("No metric selected");
        }

        toggle();
    }

    const showSearch = (): boolean => {
        return metricsValidAsFilter.length > 5;
    }

    const getDropdownContent = () => {
        return (
            <DropdownMenu end={props.end}>
                <CSSTransition in={!secondPageActive} timeout={200} classNames="filter-dropdown-page-one">
                    <div className="filter-dropdown-page-one">
                        {showSearch() &&
                            <>
                                <SearchInput id="metric-search-input" onChange={(text) => setSearchQuery(text)} text={searchQuery} autoFocus={true} />
                                <DropdownItem divider />
                            </>
                        }
                        {getMatchedMetrics()}
                        {getNewVariableButton()}
                    </div>
                </CSSTransition>
                <CSSTransition in={secondPageActive} timeout={200} classNames="filter-dropdown-page-two">
                    <div className="filter-dropdown-page-two">
                        <button className="filter-name" onClick={goToFirstPage}>
                            <i className="material-symbols-outlined back-icon">chevron_left</i>
                            <div className="name-container">
                                {!selectedMetric?.isBasedOnCustomVariable && <div className="var-name">{selectedMetric?.varCode}</div>}
                                <div className="title">{getMetricDisplayName(selectedMetric)}</div>
                            </div>
                        </button>
                        <DropdownItem divider />
                        {selectedMetric
                            ? <FilterValueMappingSelector
                                id="add-filter-btn"
                                selectedMetric={selectedMetric!}
                                selectedFilters={selectedFilters}
                                setSelectedFilters={setSelectedFilters}
                                showApplyButtons={true}
                                onApply={(filters) => applyFilter(filters)}
                                close={toggle}
                            />
                            : <div className="empty-dropdown" />
                        }
                    </div>
                </CSSTransition>
            </DropdownMenu>
        );
    }

    return (
        <div className="add-filter-button">
            <div className="metric-dropdown-menu">
                <ButtonDropdown isOpen={isOpen} toggle={toggle} className="metric-dropdown">
                    <DropdownToggle caret className="hollow-button" tag="button">
                        <i className="material-symbols-outlined">filter_alt</i>
                        <div>Filter</div>
                    </DropdownToggle>
                    {getDropdownContent()}
                </ButtonDropdown>
            </div>
            <VariableContentModal
                isOpen={isVariableModalOpen}
                subsetId={subsetId}
                setIsOpen={setIsVariableModalOpen}
                reportAppendType={ReportVariableAppendType.Filters}
                shouldSetQueryParamOnCreateOverride={false}
            />
        </div>
    );
}

export default AddFilterButton;