import React from "react";
import { useEffect } from "react";
import * as BrandVueApi from "../BrandVueApi";
import { SwaggerException } from "../BrandVueApi";
import Footer from "../components/Footer";
import AceEditor from "react-ace";
import {Toaster, toast} from 'react-hot-toast';
import { ProductConfigurationContext } from "../ProductConfigurationContext";
import WarningBanner from "../components/visualisations/WarningBanner";
import { WeightingsExport } from "./WeightingsExport";
import {useTagManager} from "../TagManagerContext";
import { handleError } from "client/components/helpers/SurveyVueUtils";

interface IWeightingProps {
    nav: React.ReactNode;
}

const replacer = (key, value) => typeof value === 'undefined' ? null : value;

export const WeightingsConfiguration: React.FunctionComponent<IWeightingProps> = ((props: IWeightingProps) => {
    const { productConfiguration } = React.useContext(ProductConfigurationContext);
    const weightingsConfigClient = BrandVueApi.Factory.WeightingPlansClient(error => error());
    const metricClient = BrandVueApi.Factory.MetricsClient(error => error());
    const [originalContent, setOriginalContent] = React.useState('');
    const [editorContent, setEditorContent] = React.useState(originalContent);
    const [isCurrentlySaving, setIsCurrentlySaving] = React.useState(false);
    const [allowedMetricIds, setAllowedMetricIds] = React.useState(new Set<string>());
    const [messages, setMessages] = React.useState<BrandVueApi.AutoGeneratedMessage[]>([]);
    const tagManager = useTagManager()
    const autoGenerateWeightings = () => {
        weightingsConfigClient.getWeightingPlansFromConfiguration().then(weightings => {
            const unneededPropertiesRemoved = weightings.roots.map(w => {
                const json = w.toJSON();
                for (const plan of json.uiWeightingPlans) {
                    RemoveIds(plan);
                }
                return json;
            });
            const loadedContent = JSON.stringify(unneededPropertiesRemoved, replacer, 4);
            setEditorContent(loadedContent);
            setMessages(weightings.messages)
        }).catch(ex => { toast.error("Failed autogenerating")});
        
    }

    const createWeightings = () => {
        let attemptedParse: BrandVueApi.UiWeightingConfigurationRoot[];
        setIsCurrentlySaving(true);
        try {
            tagManager.addConfigurationEvent("weightingsConfigureUpdate");
            try {
                attemptedParse = JSON.parse(editorContent);
                const metricIds = attemptedParse.flatMap(r => r.uiWeightingPlans)
                    .flatMap(p => p.variableIdentifier)
                    .filter((thisOne, thisIndex, arr) => arr.findIndex(anotherOne => anotherOne === thisOne) === thisIndex)
                    .filter (x=> x != null);
                const badMetricIds = metricIds.filter(m => !allowedMetricIds.has(m));
                if (badMetricIds.length > 0) {
                    toast.error(`Invalid variable identifiers: ${badMetricIds.join(',')}`);
                    setIsCurrentlySaving(false);
                    return;
                }
            } catch (e) {
                toast.error("Failed to parse target weighting - invalid JSON");
                throw e;
            }
        } catch (e) {
            setIsCurrentlySaving(false);
            throw e;
        }
        return weightingsConfigClient.createWeightingPlans(attemptedParse)
            .then(() => location.reload())
            .catch((e: SwaggerException) => {
                const defaultErrorMessage = "An error occurred trying to create target weighting";
                const extraErrorContext = e.response ? JSON.parse(e.response).message : null;
                toast.error(extraErrorContext ?? defaultErrorMessage);
                setIsCurrentlySaving(false);
                throw e;
            });
    }

    function RemoveIds(plan: any) {
        delete plan.id;

        for (const target of plan.uiChildTargets) {
            delete target.id; // Displaying id is not needed - id's are changed on POST anyway.
            for (const childPlan of target.uiChildPlans) {
                RemoveIds(childPlan);
            }
        }
    }

    useEffect(() => {
        weightingsConfigClient.getWeightingPlans().then(weightings => {
            const unneededPropertiesRemoved = weightings.map(w => {
                const json = w.toJSON();
                for (const plan of json.uiWeightingPlans) {
                    RemoveIds(plan);
                }
                return json;
            });
            const loadedContent = JSON.stringify(unneededPropertiesRemoved, replacer, 4);
            setOriginalContent(loadedContent);
            setEditorContent(loadedContent);
        }).catch((e: Error) => handleError(() => {throw e}));

        metricClient.getMetricConfigurations()
            .then((metrics) => setAllowedMetricIds(new Set<string>(metrics.map(m => m.name))));

    }, []);

    const warningMessage = () => {
        if (messages.length > 0) {
            const text = messages.map(x => `${x.subset} - ${x.message}`);
            return (
                <WarningBanner
                    message={`${messages.length} errors: ${text}`}
                    materialIconName="error"
                />
            );
        }
    }
    const displayError = (message: string) => {
        toast.error(message);
    }
    return <div className="configuration-page">
        <Toaster position='bottom-center' toastOptions={{duration: 5000}} />
        {props.nav}
        <div className="view-chart-configurations">
            <div className="existing-configurations">
                {warningMessage()}
                <AceEditor
                    height={messages.length == 0 ? "100%" : "85%"}
                    width="100%"
                    mode="json"
                    theme="monokai"
                    name="ace-editor"
                    value={editorContent}
                    onChange={(e) => setEditorContent(e)}
                    fontSize={14}
                    showPrintMargin={false}
                    showGutter={true}
                    highlightActiveLine={false}
                    enableBasicAutocompletion={true}
                    wrapEnabled={true}
                    setOptions={{
                        showLineNumbers: true,
                        showFoldWidgets: true,
                        tabSize: 8,
                    }}
                />
                <div className="configuration-footer">
                    <button className="primary-button" onClick={createWeightings} disabled={isCurrentlySaving || originalContent === editorContent}>{originalContent === editorContent ? "Saved" : isCurrentlySaving ? "Saving..." : "Save"}</button>
                    <WeightingsExport displayError={displayError} />
                    <div>
                        {!productConfiguration.isSurveyVue() && productConfiguration.isFeatureEnabled(BrandVueApi.Features.FeatureFlagAllowReadingOfWeightsViaWeightingPlan) && originalContent == '[]' &&
                            <button className="primary-button" onClick={autoGenerateWeightings}> Autogenerate Weightings from Quota Cells</button>
                        }
                        {!productConfiguration.isSurveyVue() && productConfiguration.isFeatureEnabled(BrandVueApi.Features.FeatureFlagAllowReadingOfWeightsViaWeightingPlan) && originalContent != '[]'  &&
                            <div>Loading weighting from plans</div>
                        }
                    </div>
                </div>
            </div>
        </div>


        <Footer />
    </div>;
});
