import React from "react";
import {useState} from "react";
import {preciseSum, toPercentage} from "../helpers/MathHelper";
import Throbber from "../components/throbber/Throbber";
import Tooltip from "../components/Tooltip";
import { getMetricDisplayName } from "../components/helpers/SurveyVueUtils";
import DeleteWeightingModal from "../components/visualisations/Settings/Weighting/Modals/DeleteWeightingModal";
import { UiRimCategory, UiRimDimension } from "./WeightingPlansConfigurationPage";
import LocaleNumberTextInput from "./WeightingPlansControls/LocaleNumberTextInput";

interface IWeightingSchemeConfigurationPageProps {
    isLoading: boolean;
    showDeleteButton: boolean;
    dimensionsInScheme: UiRimDimension[];
    addQuestionsButtonHandler: () => void;
    removeDimensionHandler: (dimension: UiRimDimension) => void;
    populationSampleSize: number;
    updateDimensionTargetPercentage: (dimension: UiRimDimension, categoryWithTarget: UiRimCategory, targetPercentage: number | undefined) => void;
    updateDimensionTargetPopulation: (dimension: UiRimDimension, categoryWithTarget: UiRimCategory, targetPopulation: number | undefined) => void;
    isRimTarget?: boolean;
    isRootNode: boolean;
}

const WeightingSchemeConfigurationPage: React.FunctionComponent<IWeightingSchemeConfigurationPageProps> = (props: IWeightingSchemeConfigurationPageProps) => {
    if (props.isLoading) {
        return <div className="throbber-container"><Throbber /></div>;
    }

    if (props.isRimTarget) {
        return (
            <div className="error-message">
                <span>Cannot add questions here as this node is currently Rim weighted.</span>
            </div>
        );
    }

    if (props.dimensionsInScheme.length === 0) {
        return (
            <>
                <div className="error-message">
                    <span>Click button to get started adding questions to your weighting.</span>
                </div>
                <div className="help-link">
                    <a href="https://docs.savanta.com/allvue/Content/AllVue/Adding_Weightings_to_your_Project.html" target="_blank">
                        <i className={`style.symbol material-symbols-outlined no-symbol-fill`}>info</i>
                        <span className="link-text">How weighting works</span>
                    </a>
                </div>

                <div className="multi-button">
                    <button className="add-question-toggle primary-button button-centraliser" onClick={props.addQuestionsButtonHandler}>
                        <i className="material-symbols-outlined">add</i>
                        <div>Add questions to weighting</div>
                    </button>
                </div>
            </>
        );
    }

    return (
        <>
            {props.dimensionsInScheme.map(m =>
                <WeightingDimensionsTable
                    key={m.metric.name}
                    dimension={m}
                    removeFromScheme={props.removeDimensionHandler}
                    populationSampleSize={props.populationSampleSize}
                    updateCategoryTarget={(categoryWithTarget, targetPercentage) => props.updateDimensionTargetPercentage(m, categoryWithTarget, targetPercentage)}
                    updateCategoryPopulation={(categoryWithTarget, targetPopulation) => props.updateDimensionTargetPopulation(m, categoryWithTarget, targetPopulation)}
                    showDeleteButton={props.showDeleteButton}
                    isSingularRootNode={props.isRootNode && props.dimensionsInScheme.length === 1}
                />
            )}
        </>
    );
};

interface IDimensionTableProps {
    showDeleteButton: boolean;
    dimension: UiRimDimension;
    populationSampleSize: number;
    updateCategoryTarget: (categoryWithTarget: UiRimCategory, targetPercentage: number | undefined) => void;
    updateCategoryPopulation: (categoryWithTarget: UiRimCategory, targetPopulation: number | undefined) => void;
    removeFromScheme: (dimension: UiRimDimension) => void;
    isSingularRootNode: boolean;
}

enum TableMode {
    TargetPercentage,
    TargetPopulation
};

const WeightingDimensionsTable: React.FunctionComponent<IDimensionTableProps> = (props: IDimensionTableProps) => {
    const [tableMode, setTableMode] = React.useState<TableMode>(TableMode.TargetPercentage);

    const metric = props.dimension.metric;
    const instanceSampleSizes = props.dimension.instanceResults.map(r => r.sampleSize);
    const dimensionSampleSize = preciseSum(instanceSampleSizes);
    const lowSample = dimensionSampleSize < props.populationSampleSize;
    const helptext = metric.isAutoGeneratedNumeric() ? "Auto grouped: " + getMetricDisplayName(metric) : getMetricDisplayName(metric);
    const [currentlyDeletingWeightingPlan, setCurrentlyDeletingWeightingPlan] = React.useState<boolean>(false);

    React.useEffect(() => {
        const tableMode = props.dimension.instanceResults.some(r => r.targetPopulation != null) ?
            TableMode.TargetPopulation : TableMode.TargetPercentage;
        setTableMode(tableMode);
    }, [props.dimension.metric]);

    const getPercentageTable = () => {
        const targetPercentagesForDimension = props.dimension.instanceResults.map(r => r.targetPercentage);
        const totalTargetsForDimension = preciseSum(targetPercentagesForDimension);
        const nullTargetsSampleSize = props.dimension.instanceResults.filter(x => x.targetPercentage == null).reduce((partial, a) => partial + a.sampleSize, 0);
        const applyTargetSample = totalTargetsForDimension!= 100;
        return (
            <table className="question-table">
                <thead>
                    <tr>
                        <th>{metric.name}</th>
                        <th>Target %</th>
                        <th>Target Sample</th>
                        <th>Original %</th>
                        <th>Sample</th>
                    </tr>
                </thead>
                <tbody>
                    {props.dimension.instanceResults.map(r =>
                        <DimensionPercentageCategoryRow
                            key={r.instance.name}
                            categoryWithTarget={r}
                            dimensionSampleSize={dimensionSampleSize}
                            populationSampleSize={props.populationSampleSize}
                            updateTarget={(targetPercentage) => props.updateCategoryTarget(r, targetPercentage)}
                            nullTargetSampleSize={nullTargetsSampleSize}
                            applyTargetSample={applyTargetSample}
                        />
                    )}
                </tbody>
                <tfoot>
                    <tr>
                        <td>Target total</td>
                        <td className={`targets-total ${totalTargetsForDimension === 100 ? "" : "invalid"}`}><i className="material-symbols-outlined">warning</i>{totalTargetsForDimension}%</td>
                        <td />
                        <td />
                        <td>{dimensionSampleSize.toLocaleString()}</td>
                    </tr>
                </tfoot>
            </table>
        );
    };

    const getPopulationTable = () => {
        const totalPopulation = preciseSum(props.dimension.instanceResults.map(r => r.targetPopulation ?? 0));
        return (
            <table className="question-table">
                <thead>
                    <tr>
                        <th>{metric.name}</th>
                        <th>Target Sample</th>
                        <th>Expansion Factor</th>
                        <th>Sample</th>
                    </tr>
                </thead>
                <tbody>
                    {props.dimension.instanceResults.map(r =>
                        <DimensionPopulationCategoryRow
                            key={r.instance.name}
                            categoryWithTarget={r}
                            dimensionSampleSize={dimensionSampleSize}
                            populationSampleSize={props.populationSampleSize}
                            updateTarget={(targetPopulation) => props.updateCategoryPopulation(r, targetPopulation)}
                        />
                    )}
                </tbody>
                <tfoot>
                    <tr>
                        <td>Target total</td>
                        <td className={`targets-total`}>{totalPopulation.toLocaleString()}</td>
                        <td />
                        <td>{dimensionSampleSize.toLocaleString()}</td>
                    </tr>
                </tfoot>
            </table>
        );
    };

    const canDisplayModeToggle = props.isSingularRootNode || tableMode === TableMode.TargetPopulation;
    const toggleMessage = tableMode === TableMode.TargetPercentage ? "Switch to expansion weights" : "Switch to RIM weights";
    const toggleTableMode = () => setTableMode(tableMode === TableMode.TargetPercentage ? TableMode.TargetPopulation : TableMode.TargetPercentage);

    return (
        <>
            <DeleteWeightingModal
                isOpen={currentlyDeletingWeightingPlan}
                toggle={() => setCurrentlyDeletingWeightingPlan(false)}
                cancelDelete={() => setCurrentlyDeletingWeightingPlan(false)}
                deleteWeighting={() => props.removeFromScheme(props.dimension)}
            />
            <div className="header-right-flex">
                {lowSample && <div><i className="material-symbols-outlined">warning</i></div>}
                <div className="question-text">{helptext}</div>
                <div className="right-hand-section">
                    {canDisplayModeToggle &&
                        <button className="primary-button" onClick={toggleTableMode}>
                            <div>{toggleMessage}</div>
                            <i className="material-symbols-outlined">swap_vert</i>
                        </button>
                    }
                    {props.showDeleteButton &&
                        <i className="material-symbols-outlined delete-icon-button" title="Remove question from scheme" onClick={() => setCurrentlyDeletingWeightingPlan(true)}>
                            delete
                        </i>
                    }
                </div>
            </div>
            <div className="question-tables-container single">
                <div className="question-table-container">
                    {tableMode === TableMode.TargetPercentage && getPercentageTable()}
                    {tableMode === TableMode.TargetPopulation && getPopulationTable()}
                </div>
            </div>
        </>
    );
};

interface IDimensionPercentageCategoryRowProps {
    categoryWithTarget: UiRimCategory;
    dimensionSampleSize: number;
    populationSampleSize: number;
    updateTarget: (targetPercentage: number | undefined) => void;
    nullTargetSampleSize: number | null;
    applyTargetSample: boolean;
}

const submittableInputStateRegex = /^\d{1,3}(\.\d{1,5})?$/;
const validInputStateRegex = /^\d{1,3}(\.\d{0,5})?$/;

const DimensionPercentageCategoryRow: React.FunctionComponent<IDimensionPercentageCategoryRowProps> = (props: IDimensionPercentageCategoryRowProps) => {
    const originalPercentage = props.dimensionSampleSize > 0 ? toPercentage(props.categoryWithTarget.sampleSize / props.dimensionSampleSize) : 0;
    const initialInputValue = props.categoryWithTarget.targetPercentage != null ? props.categoryWithTarget.targetPercentage.toString() : "";
    const [targetPercentageValue, setTargetPercentageValue] = useState(initialInputValue);

    const updateTargetPercentage = (targetPercentage: string) => {
        if (targetPercentage === "") {
            props.updateTarget(undefined);
            setTargetPercentageValue(targetPercentage);
            return;
        }

        if (!validInputStateRegex.test(targetPercentage))
            return;

        const targetAsFloat = parseFloat(targetPercentage);
        if (targetAsFloat < 0 || targetAsFloat > 100)
            return;

        setTargetPercentageValue(targetPercentage);

        if (submittableInputStateRegex.test(targetPercentage))
            props.updateTarget(targetAsFloat);
    };

    const zeroSampleSize = props.categoryWithTarget.sampleSize <= 0;
    const sampleSizeSmallerThanPopulation = props.dimensionSampleSize < props.populationSampleSize;
    const inputGroup =
        <div className="target-input-group">
            <label>%</label>
            <input className="target-percentage-input" type="text" value={targetPercentageValue} disabled={zeroSampleSize || sampleSizeSmallerThanPopulation}
                onChange={e => updateTargetPercentage(e.target.value)} />
        </div>;

    const targetSample = props.applyTargetSample && targetPercentageValue.length == 0 ? props.categoryWithTarget.sampleSize : parseFloat(targetPercentageValue) * 0.01 * (props.dimensionSampleSize - (props.nullTargetSampleSize ? props.nullTargetSampleSize : 0));
    return <tr>
        <td>{props.categoryWithTarget.instance.name}
            {props.categoryWithTarget.warningText &&
                <Tooltip placement="top" title={props.categoryWithTarget.warningText} >
                    <i className="material-symbols-outlined warning">warning</i>
                </Tooltip>
        }</td>
        <td>{inputGroup}</td>
        <td>{isNaN(targetSample) ? props.categoryWithTarget.sampleSize : Math.round(targetSample).toLocaleString()}</td>
        <td>{originalPercentage.toFixed(2)}%</td>
        <td>{props.categoryWithTarget.sampleSize.toLocaleString()}</td>
    </tr>;
};

interface IDimensionPopulationCategoryRowProps {
    categoryWithTarget: UiRimCategory;
    dimensionSampleSize: number;
    populationSampleSize: number;
    updateTarget: (targetPopulation: number | undefined) => void;
}

const DimensionPopulationCategoryRow: React.FunctionComponent<IDimensionPopulationCategoryRowProps> = (props: IDimensionPopulationCategoryRowProps) => {
    const initialInputValue = props.categoryWithTarget.targetPopulation != null ? props.categoryWithTarget.targetPopulation.toString() : "";

    const updateTargetPopulation = (targetPopulation: string) => {
        if (targetPopulation === "") {
            props.updateTarget(undefined);
            return;
        }

        const parsedNumber = Number(targetPopulation);
        if (Number.isInteger(parsedNumber) && parsedNumber >= 0) {
            props.updateTarget(parsedNumber);
            return;
        }
    };

    const getExpansionFactor = () => {
        if (props.categoryWithTarget.targetPopulation != null) {
            if (props.categoryWithTarget.targetPopulation === 0 || props.categoryWithTarget.sampleSize === 0) {
                return `x0`;
            }
            const factor = props.categoryWithTarget.targetPopulation / props.categoryWithTarget.sampleSize;
            return `x${factor.toFixed(2)}`;
        }
    };

    const zeroSampleSize = props.categoryWithTarget.sampleSize <= 0;
    const sampleSizeSmallerThanPopulation = props.dimensionSampleSize < props.populationSampleSize;
    const inputGroup = (
        <div className="target-input-group">
            <LocaleNumberTextInput className="target-population-input"
                type="text"
                value={props.categoryWithTarget.targetPopulation}
                disabled={zeroSampleSize || sampleSizeSmallerThanPopulation}
                onChange={e => updateTargetPopulation(e.target.value)} />
        </div>
    );

    return (
        <tr>
            <td>{props.categoryWithTarget.instance.name}
                {props.categoryWithTarget.warningText &&
                    <Tooltip placement="top" title={props.categoryWithTarget.warningText} >
                        <i className="material-symbols-outlined warning">warning</i>
                    </Tooltip>
            }</td>
            <td>{inputGroup}</td>
            <td>{getExpansionFactor() ?? "-"}</td>
            <td>{props.categoryWithTarget.sampleSize.toLocaleString()}</td>
        </tr>
    );
};

export default WeightingSchemeConfigurationPage;
