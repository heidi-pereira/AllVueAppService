<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6.1" />
  </startup>
  <appSettings>
    <!-- Logging -->
    <add key="Logging.ConsoleLevel" value = "Information" />
    <add key="Logging.FileLevel" value = "Information" />
    <add key="Logging.AggregatorLevel" value = "None" />
    <add key="Logging.AggregatorApiKey" value = "" />
    <add key="Logging.Environment" value = "Debug" />
    <add key="Logging.AppName" value = "DashboardBuilder" />
    <add key="MapFileErrors.DestinationEmail" value="team.enigma@savanta.com" />

    <!-- If you don't have the egnyte I drive (e.g. on non-mig hardware, download & unzip the latest metadata package from TeamCity and point at that -->
    <add key="Egnyte.Dashboards.LocalReadOnly" value="I:\Shared\Systems\Dashboards\" />

    <!-- On Alistair's machine, used to be things like "C:\Users\Alistair\Dropbox (Morar Consulting)\ModelBuilder\BrandVue\ or C:\Users\Alistair\Documents\GitHub\MyVue\ or C:\Users\Alistair\Dropbox (Morar Consulting)\ModelBuilder\Generic\ -->
    <!-- On cloud builds, used to be things like "D:\inetpub\wwwroot\htdocs\secure\" followed by   "renaultlatest\testdata\ren\update", "wagamama\testdata\wag", "FitnessFirst\testdata\ff" or "FitnessFirstAustralia\testdata\ffoz"-->
    <add key="OverrideOutputPath" value="../../../../../testdata" />

    <!-- On live: /Shared/Systems/Dashboards/ -->
    <add key="Egnyte.Dashboards.Remote" value="/Shared/Development/Projects/Dashboards/AutomatedUse/DevMachine/" />
    <add key="Egnyte.Subdomain" value="morarc" />
    <!-- A new one can be generated quite easily using EgnyteClient.WriteBearerTokenToConsoleAsync - Octopus and TeamCity have the tokens for some locked down accounts it uses -->
    <add key="Egnyte.BearerToken" value="" />

    <!-- On live: true. Package output and send to Octopus for deployment - set to false if you want to run locally-->
    <add key="PackageOutput" value="false" />
    <add key="Packager.OctoUrl" value="Remember to replace this on octopus with $OctopusParameters['Octopus.Web.BaseUrl']" />
    <add key="Packager.OctoApiKey" value="Remember to replace this on octopus" />
    <add key="Packager.ShouldDeleteAfterPush" value="true" />

    <add key="LiveBuild" value="false" />
  </appSettings>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="Newtonsoft.Json" publicKeyToken="30AD4FE6B2A6AEED" culture="neutral"/>
        <bindingRedirect oldVersion="0.0.0.0-12.0.0.0" newVersion="12.0.0.0"/>
      </dependentAssembly>
    </assemblyBinding>

    <!--

    A limitation of .NET runtimes prior to .NET 4.5 is a maximum object size allowed on the heap of 2 GB,
    even on 64-bit versions.
    
    From 4.5 onwards the below option relaxes the limit on 64-bit runtimes.
    
    We're doing this because, with the growth in data being collected, we're now seeing dictionaries within
    DashboardBuilder that appear to be breaching this limit.

    It's not ideal but it also won't last long.

    For more information please see:

    https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element?redirectedfrom=MSDN

    N.B., This will also break eventually since arrays are 32-bit indexed, and with signed integers at that, meaning no more than 2.1B records.
    However, with 64-bit references, any reference type array will only be able to store ~250M records in 2GB, so this flag will give us a
    decent amount of headroom. For 32-bit ints it would be ~500M so, again, a reasonable amount of headroom for now.

    -->
    <gcAllowVeryLargeObjects enabled="true" />
  </runtime>
</configuration>
