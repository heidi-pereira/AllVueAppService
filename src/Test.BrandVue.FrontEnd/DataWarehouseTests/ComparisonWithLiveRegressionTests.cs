//#define AUTOMERGE
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Json;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Autofac;
using BrandVue.PublicApi.Controllers;
using BrandVue.PublicApi.Models;
using BrandVue.PublicApi.Services;
using CsvHelper;
using Newtonsoft.Json;
using NUnit.Framework;
using VerifyNUnit;
using VerifyTests;
using CsvReader = LumenWorks.Framework.IO.Csv.CsvReader;


namespace Test.BrandVue.FrontEnd.DataWarehouseTests
{

    /// <summary>
    /// These depend on the app.config pointing to a real restored DataWarehouse db from here: https://savantaftp.egnyte.com/
    /// Also see the settings prefixed with "DataWarehouseTests" which you can point to the beta environment with a beta api key for example
    /// </summary>

    [Explicit]
    [TestFixture]
    class ComparisonWithLiveRegressionTests
    {

        //===================================================================================
        // NOTES:
        // We have two tests here that are currently designed for local dev use
        // - VerifyMetricsLocal
        // - VerifyDeployedEnvironment
        //
        // appSettings.datawarehousetests.json is used to configure things for the tests
        // - you can override db conn strings here if needs be
        // A Verify folder will be created by each test for individual files
        // File names are set to the metric being tested (enables copying to other tests)
        //                                                                                        
        // TO DO:
        // - Gitignore verify snapshot files generated by the tests?
        //
        //===================================================================================


        /// <summary>
        /// Locally you can set this to int.MaxValue, it's just a small number to keep TeamCity builds fast
        /// </summary>
        private const int MaxMetricsToTest = 100;

        /// <summary>
        /// Increasing this number increases the number of data points returned (and stored)
        /// Verify will create a new folder when MaxClassInstances is changed (and not already exists)
        /// </summary>
        private const MaxClassInstances MaxClassInstancesToTest = MaxClassInstances.Three;

        private DateTimeOffset startDate = new DateTimeOffset(new DateTime(2024, 08, 01));
        private DateTimeOffset endDate = new DateTimeOffset(new DateTime(2024, 08, 31));

        [TestCaseSource(typeof(TestDataProvider), nameof(TestDataProvider.Products))]
        public async Task ShouldHaveMetricForEachVerifiedFile(ProductToTest productToTest)
        {
            var metricAndClasses = TestDataProvider.MetricsForProduct(LocalBrandVueServer.For(productToTest), maxClassInstancesToTest: (int)MaxClassInstancesToTest).ToArray();
            var availableMetricsById = metricAndClasses
                .Select(c => ConvertToValidFileName(c.ToPath())).ToHashSet(StringComparer.OrdinalIgnoreCase);
            string[] verifiedFileNames = Directory.GetFiles(Path.Combine(CurrentFile.Directory(), productToTest.ToString()), "*.verified.csv",SearchOption.AllDirectories);

            int startIndex = CurrentFile.Directory().Length+1;
            var metricIdsWithFiles = verifiedFileNames.
                Select( x=> x.Substring(startIndex).Replace(".verified.csv", ""))
                .ToHashSet(StringComparer.OrdinalIgnoreCase);
            Assert.That(metricIdsWithFiles, Is.Not.Empty, "Test setup issue");
            var unavailableMetricIdsWithFiles = metricIdsWithFiles.Except(availableMetricsById).ToArray();
            Assert.That(unavailableMetricIdsWithFiles, Is.Empty, unavailableMetricIdsWithFiles.Length + " missing metrics");
        }

        /// <summary>
        /// This test is designed for local dev usage
        /// when run it will mock the MetricResultsApiController fetch a list of metrics and then generate a test for each metric
        /// Once data for the metric is retrieved we run verify to validate the data against a snapshot file
        /// If no snapshot file exists for the metrics test then we use AutoVerify to create it from the data
        /// when the test is next run for that metric there will be a snapshot file to compare against
        /// </summary>
        /// <param name="metric"></param>
        /// <returns></returns>
        [Parallelizable(ParallelScope.Children)]
        [TestCaseSource(typeof(TestDataProvider), nameof(TestDataProvider.MetricsForProducts), new object[] { MaxMetricsToTest, MaxClassInstancesToTest })]
        public async Task VerifyMetricsLocal(MetricAndClass metric)
        {
            var fileAndPath = ConvertToValidFileName(metric.ToPath());
            var thisDir = Path.GetDirectoryName(fileAndPath);
            var fileName = Path.GetFileName(fileAndPath);
            var snapshotFilePath = GetSnapshotFilePath(thisDir, fileName);

            bool fileExists = File.Exists(snapshotFilePath);
#if AUTOMERGE
            var automerge = true;
#else
            var automerge = false;
#endif

            var verifySettings = VerifySetup(thisDir, fileName, true, automerge);
            var metricResultsApiController = LocalBrandVueServer.For(metric.ProductToTest).LifetimeScope.Resolve<MetricResultsApiController>();

            Console.WriteLine(snapshotFilePath);
            try
            {
                var testData = await GetValueLocal(metric, metricResultsApiController, startDate, endDate);
                await Verifier.Verify(testData, "csv", verifySettings);
                Console.WriteLine(metric);
                Console.WriteLine("***DATA***");
                Console.WriteLine(testData);
            }
            catch when (!fileExists)
            {
                var fileVerifyTestCreated = snapshotFilePath.Replace("verified.csv", "received.csv");
                File.Move(fileVerifyTestCreated, snapshotFilePath, true);
                Assert.Ignore($"Auto created validation file for this metric.{Environment.NewLine}");
            }
        }

        [Parallelizable(ParallelScope.Children)]
        [TestCaseSource(typeof(TestDataProvider), nameof(TestDataProvider.ClassesForProducts))]
        // iterate over all the entity types + get all the instances
        public async Task VerifyConfigLocal(Class entityClass)
        {
            var fileAndPath = ConvertToValidFileName(entityClass.ToPath());
            var thisDir = Path.GetDirectoryName(fileAndPath);
            var fileName = Path.GetFileName(fileAndPath);
            var snapshotFilePath = GetSnapshotFilePath(thisDir, fileName).Replace(".csv", ".txt");

            bool fileExists = File.Exists(snapshotFilePath);
#if AUTOMERGE
            var automerge = true;
#else
            var automerge = false;
#endif

            var verifySettings = VerifySetup(thisDir, fileName, true, automerge);
            var classesApiController = LocalBrandVueServer.For(entityClass.ProductToTest).LifetimeScope.Resolve<ClassesApiController>();

            Console.WriteLine(snapshotFilePath);
            try
            {
                var testData = GetClassInstancesLocal(entityClass, classesApiController);
                await Verifier.Verify(testData, verifySettings);
                Console.WriteLine(entityClass);
                Console.WriteLine("***DATA***");
                Console.WriteLine(testData);
            }
            catch (Exception e) when (!fileExists && e.StackTrace == "")
            {
                var fileVerifyTestCreated = snapshotFilePath.Replace("verified.txt", "received.txt");
                File.Move(fileVerifyTestCreated, snapshotFilePath, true);
                Assert.Ignore($"Auto created validation file for this metric.{Environment.NewLine}");
            }
        }


        private static string GetSnapshotFilePath(string thisDir, string fileName) => 
            Path.Combine(CurrentFile.Directory(), thisDir.Replace("/", "\\"), fileName + ".verified.csv");


        /// <summary>
        /// Useful for local dev to compare local mocked data (post migration) to data from api in test env
        /// Verified data will be generated from the deployed API (test) - *be aware of rate limiting
        /// If the verified files already exist then the api call will not be made
        /// Data is then retrieved from mock API and we verify the result od that against the snapshot files
        /// </summary>
        /// <param name="metric"></param>
        /// <returns></returns>
        [Parallelizable(ParallelScope.Children)]
        [Retry(3)]
        [TestCaseSource(typeof(TestDataProvider), nameof(TestDataProvider.MetricsForProducts), new object[] { MaxMetricsToTest, MaxClassInstancesToTest })]
        public async Task VerifyDeployedEnvironment(MetricAndClass metric)
        {
            var fileAndPath = ConvertToValidFileName(metric.ToPath());
            var thisDir = Path.GetDirectoryName(fileAndPath);
            var fileName = Path.GetFileName(fileAndPath);
            var snapshotFilePath = GetSnapshotFilePath(thisDir, fileName);

            bool fileExists = File.Exists(snapshotFilePath);

#if AUTOMERGE
            var automerge = true;
#else
            var automerge = false;
#endif
            var verifySettings = VerifySetup(thisDir, fileName, true, automerge);

            try
            {
                var testData = await GetValueDeployedApi(metric, startDate, endDate);
                await Verifier.Verify(testData, "csv", verifySettings);
            }
            catch when (!fileExists)
            {
                Assert.Ignore("No validation file for this metric.");
            }
        }

        private VerifySettings VerifySetup(string thisDir, string fileName, bool disableDiff, bool autoVerify)
        {
            var verifySettings = new VerifySettings();
            verifySettings.UseDirectory(thisDir);
            verifySettings.UseFileName(fileName);
            verifySettings.DontScrubDateTimes();
            if (autoVerify)
                verifySettings.AutoVerify();

            if (disableDiff)
                verifySettings.DisableDiff();

            return verifySettings;
        }

        private async Task<string> GetValueDeployedApi(MetricAndClass metric, DateTimeOffset startDate, DateTimeOffset endDate)
        {
            var payload = new MetricCalculationRequest(startDate, endDate, metric.Classes);

            var start = DateTime.Now;

            HttpResponseMessage liveDataResult;
            using (var brandVueApiClient = LocalBrandVueServer.For(metric.ProductToTest).CreateBrandVueApiClient())
            {
                liveDataResult = await brandVueApiClient.PostAsync(metric.RelativeUri, JsonContent.Create(payload));
            }

            if (liveDataResult.StatusCode != HttpStatusCode.OK)
            {
                Assert.Ignore("Remote API Error: " + liveDataResult.StatusCode + " " +
                              await liveDataResult.Content.ReadAsStringAsync());
                return null;
            }

            var liveDataCsv = await liveDataResult.Content.ReadAsStreamAsync();
            string csvWithFormattedFloats = await GetCsvWithFormattedDoubles(liveDataCsv, "G5");
            Console.WriteLine(DateTime.Now.Subtract(start).TotalMilliseconds);
            return csvWithFormattedFloats;
        }

        private static async Task<string> GetValueLocal(MetricAndClass metric,
            MetricResultsApiController metricResultsApiController, DateTimeOffset startDate, DateTimeOffset endDate)
        {
            var start = DateTime.Now;
            var results = await metricResultsApiController.GetMetricResults(metric.SurveySet, metric.Metric,
                metric.Average,
                new MetricCalculationRequest(startDate, endDate, metric.Classes), CancellationToken.None);

            MetricResult[] data = null;
            string[] headerRecords = null;
            if (results is StreamedCsvResult csvStream)
            {
                await using var memoryStream = new MemoryStream();
                var toDispose = await csvStream.WriteAsync(memoryStream);
                memoryStream.Position = 0;
                string csvWithFormattedFloats = await GetCsvWithFormattedDoubles(memoryStream, "G5");
                
                foreach (var disposable in toDispose)
                {
                    await disposable.DisposeAsync();
                }
                Console.WriteLine(DateTime.Now.Subtract(start).TotalMilliseconds);
                return csvWithFormattedFloats;
            }
            else 
            {
                string serializeObject = JsonConvert.SerializeObject(results);
                
                if (JsonConvert.DeserializeObject<ApiResponse<ErrorApiResponse>>(serializeObject) is { Value: { Error: var error, Message: var message } })
                {
                    Assert.Fail(message + "\r\n" + error);
                }
                Assert.Fail(serializeObject);
                throw new UnreachableException();
            }
        }

        private static IReadOnlyCollection<ClassInstanceDescriptor> GetClassInstancesLocal(Class entityClass,ClassesApiController classesApiController)
        {
            var instances = TestDataProvider.GetSomeClassInstances(classesApiController, entityClass.SurveySet, entityClass.ClassDescriptor, int.MaxValue);
            return instances;
        }

        private static async Task<string> GetCsvWithFormattedDoubles(Stream stream, string doubleFormat)
        {
            using var streamReader = new StreamReader(stream);
            var writer = new StringWriter();
            using (var csvReader = new CsvReader(streamReader, true))
            await using (var csvWriter = new CsvWriter(writer, CultureInfo.CurrentCulture))
            {
                foreach (string fieldHeader in csvReader.GetFieldHeaders())
                {
                    csvWriter.WriteField(fieldHeader);
                }
                await csvWriter.NextRecordAsync();

                while (csvReader.ReadNextRecord())
                {
                    for (int index = 0; index < csvReader.FieldCount; index++)
                    {
                        var val = csvReader[index];
                        if (val.Contains('.') && double.TryParse(val, out var f))
                        {
                            val = f.ToString(doubleFormat);
                        }
                        csvWriter.WriteField(val);
                    }

                    await csvWriter.NextRecordAsync();
                }
            }

            return writer.ToString();
        }

        private static string ConvertToValidFileName(string input)
        {
            string invalidChars = new string(Path.GetInvalidFileNameChars().Where(x=> x!='\\').ToArray()) + new string(Path.GetInvalidPathChars());
            return string.Join("_", input.Split(invalidChars.ToCharArray(), StringSplitOptions.RemoveEmptyEntries));
        }
 
        private static class CurrentFile
        {
            public static string Directory([CallerFilePath] string file = "") =>
                System.IO.Path.GetDirectoryName(file)!;
        }

        private enum MaxClassInstances
        {
            One = 1,
            Two = 2,
            Three = 3,
            Five = 5,
            Ten = 10
        }

    }
}
